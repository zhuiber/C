在循环的过程中，使用 `% n` 是为了确保索引 `index` 在每一步后仍然在数组的有效范围内。这是因为我们在处理一个环形队列，也就是说，最后一个人之后是第一个人。这是一种常见的技巧，用来处理循环列表或环形缓冲区。

以下是详细解释：

### 为什么使用 `% n`

1. **环形结构**：由于问题描述中提到的人围坐成一个圈，当我们从最后一个人（例如第 `n` 个人）继续报数时，下一个人应该是第一个人（即编号为 `1` 的人）。使用 `% n` 可以实现这种环形结构。
2. **数组越界保护**：数组的索引从 `0` 到 `n-1`，通过使用 `% n` 可以防止索引超出数组的范围。例如，如果 `index` 为 `n`，则 `index % n` 会变成 `0`，即第一个人的位置。

### 代码逻辑

```c
// Move m-1 steps forward (because index is already at one person)
for (int i = 1; i < m; i++) {
    index = (index + 1) % n; // Move to the next person in the circle
    while (people[index] == 0) { // Skip eliminated people
        index = (index + 1) % n; // Continue moving if the person is already eliminated
    }
}
```

- **for 循环**：从 `1` 到 `m-1` 循环，用于报数 `m` 次。
  - 每次循环中，`index = (index + 1) % n`：将 `index` 增加 `1`，然后对 `n` 取模。这样确保 `index` 始终在 `0` 到 `n-1` 之间。
  - `while (people[index] == 0)`：检查当前索引处的人是否已被淘汰（标记为 `0`）。
    - 如果是，则继续移动到下一个人，直到找到一个未被淘汰的人。

### 举个例子

假设 `n = 5`，`m = 3`，`s = 1`，初始状态为 `[1, 2, 3, 4, 5]`：

1. 初始 `index = s - 1 = 0`，从第一个人开始报数。
2. 报数到 `3`：
   - 第一次 `index` 从 `0` 变为 `1`，即 `2` 号人。
   - 第二次 `index` 从 `1` 变为 `2`，即 `3` 号人。
   - 第三次 `index` 从 `2` 变为 `3`，即 `4` 号人。
3. 淘汰 `4` 号人，数组变为 `[1, 2, 3, 0, 5]`，`index` 移到下一个人 `5` 号人。
4. 重复以上步骤，直到所有人都被淘汰。

这个方法保证了每次报数和淘汰的过程中，索引始终在有效范围内，并正确处理环形结构。

如果没有 `% n`，索引会超出数组范围，导致访问越界错误（例如 `index` 变成 `n` 或更大）。这就是使用 `% n` 的原因。